{"./":{"url":"./","title":"简介","keywords":"","body":"Go 语言知识库 LICENSE 参考 Go cheatsheet 系统调用在 Golang 中的实践 Go 社区的知识图谱 Welcome to a tour of Go Go 语言标准库 深入解析 Go 语言 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"setup/code.html":{"url":"setup/code.html","title":"How to Write Go Code","keywords":"","body":"How to Write Go Code 代码组织结构 通常所有代码放在一个 工作区（workspace） 工作区包含多个版本控制的 仓库（repository） 每个仓库包含一个或多个 包（package） 每个包包含一个或多个在同一目录的 Go 源码文件 包的路径决定了其 导入路径（import path） 不同于其他编程环境，Go 的每一个项目都有一个单独的工作区，工作区和版本控制仓库紧密相连 工作区 工作区（Workspace）包含两个子目录： 子目录 描述 src 包含一个或多个版本控制仓库 bin 包含一个或多个可执行命令 $ tree $GOPATH bin/ hello # command executable outyet # command executable src/ github.com/golang/example/ .git/ # Git repository metadata hello/ hello.go # command source outyet/ main.go # command source main_test.go # test source stringutil/ reverse.go # package source reverse_test.go # test source golang.org/x/image/ .git/ # Git repository metadata bmp/ reader.go # package source writer.go # package source ... (many more repositories and packages omitted) ... 导入路径（import path） 参考 How to Write Go Code Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"setup/installation.html":{"url":"setup/installation.html","title":"安装与配置","keywords":"","body":"Go 的安装与配置 下载安装 Linux $ wget https://dl.google.com/go/go1.11.11.linux-amd64.tar.gz # 下载 $ sudo tar -xzvf /tmp/go1.11.11.linux-amd64.tar.gz -C /usr/local # 解压 # 验证 $ go version macOS $ wget https://dl.google.com/go/go1.11.11.darwin-amd64.tar.gz # 下载 $ sudo tar -zxvf go1.11.11.darwin-amd64.tar.gz -C /usr/local # 解压 # 验证 $ go version go version go1.11.11 darwin/amd64 配置环境变量 变量名 变量值 示例 GOROOT Go 安装路径 export GOROOT=/usr/local/go GOPATH 工作区路径；相应的源码路径是 $GOPATH/src export GOPATH=~/go GOBIN 可执行程序（go install）的安装路径（访问的是 $GOPATH 下的项目） export GOBIN=$GOPATH/bin 实施配置： # Linux/macOS $ vi ~/.bash_profile # 系统级：/etc/profile export GOROOT=/usr/local/go export GOPATH=~/go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOROOT/bin:$GOBIN # 立即生效 $ source ~/.bash_profile 验证配置： # 验证 GOROOT、GOPATH 和 GOBIN $ go env GOROOT $ go env GOPATH $ go env GOBIN # 验证 PATH $ go version go version go1.11.11 linux/amd64 # Linux go version go1.11.11 darwin/amd64 # macOS 注： bash -> ~/.bash_profile / ~/.bashrc zsh -> ~/.zshrc 系统级别 -> /etc/profile 测试安装 # 在工作区中创建 src/hello 项目 $ mkdir -p $GOPATH/src/hello $ cd $GOPATH/src/hello $ vi hello.go package main import \"fmt\" func main() { fmt.Printf(\"hello, world\\n\") } go build $ cd $GOPATH/src/hello # 构建（项目中可以创建多个 go 源文件，但总共只能定义一个 main() 方法） $ go build # 生成了一个同名的可执行二进制文件 $ ls $GOPATH/src/hello hello hello.go # 运行 $ ./hello hello, world go install $ cd $GOPATH/src/hello # 安装二进制到工作区的 bin 目录（即 GOBIN） $ go install $ ls $GOBIN dlv godef gometalinter gopkgs goreturns guru gocode golint go-outline gorename go-symbols hello # -_- # 直接执行 $ hello hello, world # 移除安装到 GOBIN 的二进制文件 $ go clean -i 卸载 # 第一步 $ rm -rf /usr/local/go # 第二步：移除环境变量 参考 Getting Started Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"setup/package-manager.html":{"url":"setup/package-manager.html","title":"包管理器","keywords":"","body":"Go 包管理器 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"setup/version-manager.html":{"url":"setup/version-manager.html","title":"版本管理器","keywords":"","body":"Go 版本管理器（Go Version Manager） GVM 安装 bash Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"quickstart.html":{"url":"quickstart.html","title":"入门","keywords":"","body":"Go 入门 基本程序结构 package main // 代码所在的包 import \"fmt\" // 导入代码模块 // 主函数 func main() { fmt.Println(\"Hello, world\") } 程序入口 必须是 main 包 必须是 func main() {} 函数 文件名不一定是 main.go 命令行参数 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"datatype/":{"url":"datatype/","title":"数据类型","keywords":"","body":"Go 语言数据类型 基础数据类型 布尔类型：bool 整数类型：int8 uint8 int16 uint16 int32 uint32 int64 uint64 int uint rune byte complex128 complex64，其中，byte 是 int8 的别名 int：整数默认是 int 类型；在 32 位系统下是 int32，在 64 位系统下是 int64 浮点类型：float32 float64（浮点数默认是 float64 类型） 字符串类型：string 字符类型： rune，是 int32 的别名 万能类型： interface{} 空： nil 其中，int、uint 和 `` 在 64 位系统上占用 64 位，在 32 位系统上占用 32 位。 复合数据类型 指针 结构体 数组 切片 Map 零值 没有被显示初始化的变量会被赋予相应的 零值（zero value），也称为 空值。不同类型的变量会有不同的空值： | 类型 | 对应空值 | | 数值型 | 0 | | 布尔型 | false | | 字符串 | \"\" | | Map 指针 | nil | 类型转换 类型转换用于将一种类型的变量转换为另一种类型的变量。 语法格式 T(v) // 将值 v 转换为类型 T 范例 a := 3 b := 3.5 sum1 := a + b // 不允许（C 语言允许） sum2 := a + int(b) // 强制类型转换，保持类型一致 类型推断 当声明一个不带显示类型的变量时，变量的类型会根据右侧的值自动推断。 当声明的右侧是有类型的，新变量的类型与其相同： var i int j := i // j is an int 当右侧包含一个无类型的数字常量时，新变量的类型取决于常量的精度： i := 42 // int f := 3.142 // float64 g := 0.867 + 0.5i // complex128 类型别名 // 语法 type newtypename typename // 示例 type ElemType int Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"datatype/array.html":{"url":"datatype/array.html","title":"数组","keywords":"","body":"Golang 数组（Array） 数组类型 数组类型包含 “数组大小” 和 “元素类型” 两部分，即数组大小会作为数组类型的一部分。类型 [n]T 表示 n 个 T 类型的值所组成的数组；其中，n 是数组的大小，T 是数组元素的类型。 声明 // 语法 var a [n]T // 声明一个拥有 10 个整数的数组，元素的默认值为 int 类型的零值 var a [10]int 初始化 // {} 中的元素个数可以小于等于数组长度，但 [] 中的数字必须和声明时相同 a = [10]int{1, 2, 3} // [...] 会根据数组元素个数自动推断数组大小 a = [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} 声明 + 初始化 a := [10]int{4, 5, 6} var b := [...]int{3, 2, 1} 访问数组元素 不同于 C 语言，Go 的数组变量表示的是整个数组，而不是指向第一个元素的指针。当一个数组变量被赋值或被传递的时候，实际上会复制整个数组（如果要避免复制数组，可以传递一个指向数组的指针）。 a[2] = 33 fmt.Println(a[2]) // 33 a = [10]{11, 22} // 数组变量被赋值时，数组长度不能改变 fmt.Println(a) // [11 22 0 0 0 0 0 0 0 0] 值类型与引用类型 数组是值类型，数组变量表示整个数组 切片本质是一个指向数组的指针，通过切片可以实现数组的引用传递 数组作为函数参数 由于数组变量表示的是整个数组，所以 Go 可以实现数组的值传递，缺点是它会限制函数的使用范围。 package main import \"fmt\" // 引用传递，支持任意长度的切片 func f1(arr []int) { arr[0] *= 10 } // 值传递，只能接收 [3]int 类型的数组 func f2(arr [3]int) { arr[0] *= 100 } func main() { arr := [4]int{4, 5, 6, 7} f1(arr[:]) // 引用传递：切片 arr[:] 是对数组 arr 的引用 fmt.Println(arr) // [40, 5, 6, 7] f1(arr) // 不允许，[]int 与 [4]int 类型不同 f2(arr) // 不允许，[3]int 与 [4]int 类型不同 } 形参指定了数组大小 —— 值传递（接收同类型的数组拷贝） func myFunc(param [10]int) float32 {} 形参未指定数组大小 - 引用传递（接收切片） func myFunc(param []int) float32 {} 示例： func avg(arr []int) float32 { var sum float32 var size = len(arr) for i := 0; i range range 结合 for 语句可实现遍历数组。 package main import \"fmt\" func main() { arr := [...]int{11, 22} /* * 0 11 * 1 22 */ for i, v := range arr { fmt.Println(i, v) } // 使用空白标识符忽略索引 for _, v := range arr { fmt.Println(v) } } 多维数组 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"datatype/slice.html":{"url":"datatype/slice.html","title":"切片","keywords":"","body":"Golang 切片（Slice） 切片是对其底层数组的引用，它并不存储任何数据，仅仅是描述了底层数组的一段。因此修改切片元素会修改其底层数组中对应的元素，同时与它共享底层数组的切片也会感知到这些变化。 切片类型的零值为 nil nil 切片的长度和容量为 0 切片类型 类型 []T 表示一个元素类型为 T 的切片类型。 声明 var s []T 初始化 // 直接初始化 var s []T = []T{element1, element2, ..., elementN} // 通过数组进行初始化 // 它会从数组中选择一个半开区间 [low, high)；默认的下界（low）为 0，上界（high）为数组长度，使用默认值时可以省略上下界 var s []T = arr[low:high] // 通过切片进行初始化 var s []T = sls[low:high] // 通过内置函数 make() 进行初始化 var s []T = make([]T, length, capacity) // capacity 是可选参数 字面量 数组的长度是固定的，而切片类似于没有长度的数组。切片的零值为 nil，nil 切片的长度和容量都是 0 且没有底层数组。 // 这是一个数组 [3]bool{true, true, false} // 这会创建一个和上面相同的数组，并构建一个引用它的切片 []bool{true, true, false} 内置函数 函数名 说明 len(s) 获取数组或切片的长度 cap(s) 获取数组或切片的容量 make([]T, len, cap) 创建一个动态大小的数组，并返回一个引用该数组的切片；cap 参数可选 copy(dst, src) 拷贝原切片元素到新切片 append(s []T, elems ...T) 向原切片追加新元素，并返回新切片 切片的长度等于它所包含的元素个数。 切片的容量是从切片的第一个元素开始算起，直到其底层数组的最后一个元素这之间的元素个数，即 cap(slice) == cap(underlyingArrayOfSlice) - lowBoundOfSlice。 这些内置函数均来自内置的包 builtin。 切片的切片 切片可以包含任何类型，包括其它的切片。 board := [][]string{ []string{\"_\", \"_\", _\"}, []string{\"_\", \"_\", _\"}, []string{\"_\", \"_\", _\"}, // 这里有个逗号 } board[1][1] = \"X\" 长度和容量 切片的长度是切片中的元素个数，使用 len() 方法获取 切片的容量是其底层数组的元素个数，使用 cap() 方法获取 追加元素 func append（s[]T，x ... T）[]T 原理是创建一个新数组并将原数组元素复制到新数组，最后返回新数组的新切片引用。 函数传递 切片在内部可由一个结构体类型近似表示： type slice struct { Length int Capacity int ZerothElement *byte } 多维切片 内存优化 切片本身是对底层数组的引用，只要切片存在于内存中，底层数组就不会被垃圾回收掉。 func copy(dst，src[]T)int 生成一个切片的副本，源底层数组将被回收。 范例 package main import \"fmt\" func main() { // nil 切片 var s []int // 创建数组 arr := [...]int{1, 2, 3, 4, 5} // 创建切片 sls := []int{5, 4, 3, 2, 1} // 通过引用数组创建新的切片 sls1 := arr[:] // 修改 sls1 切片元素后，arr 会被修改，并且 sls2 也会感知到 arr 的变化 sls1[2] = 33 // 通过截取数组创建新的切片（新切片容量 == cap(arr) - lowBound） sls2 := arr[2:] // 通过截取切片创建新的切片（新切片容量 == cap(sls) - lowBound） sls3 := sls[:3] // 通过内置函数 make() 创建新的切片 sls4 := make([]int, len(sls), cap(sls)*2) // 通过添加新元素创建新的切片，这不会改变原切片；如果新元素的个数少于原切片的容量，新切片的容量 sls5 := append(sls1, 6, 7) // 通过拷贝切片创建新的切片 copy(sls4, sls) fmt.Printf(\"arr=%v len=%d cap=%d type=%T\\n\", arr, len(arr), cap(arr), arr) // arr=[1 2 33 4 5] len=5 cap=5 type=[5]int fmt.Printf(\"sls=%v len=%d cap=%d type=%T\\n\", sls, len(sls), cap(sls), sls) // sls=[5 4 3 2 1] len=5 cap=5 type=[]int fmt.Printf(\"sls1=%v len=%d cap=%d type=%T\\n\", sls1, len(sls1), cap(sls1), sls1) // sls1=[1 2 33 4 5] len=5 cap=5 type=[]int fmt.Printf(\"sls2=%v len=%d cap=%d type=%T\\n\", sls2, len(sls2), cap(sls2), sls2) // sls2=[33 4 5] len=3 cap=3 type=[]int fmt.Printf(\"sls3=%v len=%d cap=%d type=%T\\n\", sls3, len(sls3), cap(sls3), sls3) // sls3=[5 4 3] len=3 cap=5 type=[]int fmt.Printf(\"sls4=%v len=%d cap=%d type=%T\\n\", sls4, len(sls4), cap(sls4), sls4) // sls4=[5 4 3 2 1] len=5 cap=10 type=[]int fmt.Printf(\"sls5=%v len=%d cap=%d type=%T\\n\", sls5, len(sls5), cap(sls5), sls5) // sls5=[1 2 33 4 5 6 7] len=7 cap=10 type=[]int fmt.Println(\"nil!\") // nil! } 参考 Go 切片：用法和本质 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"datatype/map.html":{"url":"datatype/map.html","title":"Map","keywords":"","body":"Golang map 数据类型 map 是一种无序的键值对的集合。 定义 // 声明 var map_variable map[key_type]value_type // 默认值为 nil // 使用内置函数 make() 初始化 map map_variable := make(map[key_type]value_type) // 声明 + 初始化 map_variable := map[string]int{ \"a\": 1, \"b\": 2, // 这里 , 不能少 } 键是否存在 // ok == true 则存在，对应的值为 value value, ok := map[key] 作为函数参数 如果使用 map 作为函数参数，那么调用函数时传递的是 map 的地址，即引用传递。 func f1(imap interface{}) {} func f2(imap map[string]int) {} 相等性 map 类型不能比较是否相等。 范例 package main import \"fmt\" func main() { // 声明 var amap map[string]string // 初始化 amap = make(map[string]string) amap[\"a\"] = \"A\" amap[\"b\"] = \"B\" amap[\"c\"] = \"\" /* key = a , value = A key = b , value = B key = c , value = */ for key, value := range amap { fmt.Println(\"key =\", key, \", value =\", value) } mapContainsKey(amap, \"b\") // Key found value is B mapContainsKey(amap, \"d\") // Key not found // 不能通过值是否存在的方式来判断 key 是否存在 fmt.Printf(\"val = %v, type= %T\\n\", amap[\"c\"], amap[\"c\"]) // val = , type= string fmt.Printf(\"val = %v, type= %T\\n\", amap[\"d\"], amap[\"d\"]) // val = , type= string // 删除 map 集合中的元素 delete(amap, \"c\") /* key = a , value = A key = b , value = B */ for key, value := range amap { fmt.Println(\"key =\", key, \", value =\", value) } } /* 判断 map 中是否存在某个 key 在 Go 语言中 if 语句可以包含一个条件语句和一个初始化语句 */ func mapContainsKey(dict map[string]string, key string) { // val 要么是 dict[key] 的值，要么是零值（这里是空字符串） // ok 接收一个 bool 值 if val, ok := dict[key]; ok { fmt.Println(\"Key found value is\", val) } else { fmt.Println(\"Key not found\") } } func containsKey(dict map[string]string, key string) bool { if _, ok := dict[key]; ok { return true } return false } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"datatype/pointer.html":{"url":"datatype/pointer.html","title":"指针","keywords":"","body":"Golang 指针 指针保存（指向）一个变量值的内存地址。 指针类型 类型 *T 是一个指向 T 类型值的指针类型，其对应的零值为 nil，即空指针。 var p *int // p 指向 int 型变量值 & 运算符 & 运算符生成一个指向其操作数的指针，即操作数的内存地址。 i := 123 p = &i // &i 返回 123 的内存地址 * 运算符 * 运算符表示指针指向的底层值。 fmt.Println(*p) // 通过指针 p 读取变量 i *p = 321 // 通过指针 p 修改变量 i 这就是通常说的 间接引用 或 重定向。 解引用 指针的解引用即获取指针所指向的变量的值。 pointer => *pointer $$ pointer = \\&(*pointer) $$ 指针变量作为函数参数 func f(x *int) {} 数组指针 数组指针传递给函数（不推荐，建议使用切片）： func f(arr *[3]int) { (*arr)[0] *= 10 // 特注：(*arr)[x] = arr[x] } a := [3]int{1, 3, 5} f(&a) 指针数组 语法格式 var ptr [SIZE]*variable_type 示例 package main import \"fmt\" func main() { var ptr [3]*int var arr = []int{1, 2} for i := 0; i */ for index, elem := range ptr { fmt.Println(index, elem) } } 指针运算 Go 语言不支持指针运算（C 支持）。 package main import \"fmt\" func main() { a := [...]int{1, 3, 5} p := &a fmt.Printf(\"%p %p\\n\", p, ++p) // unexpected ++, expecting expression } #include int main() { int a[] = {1, 3, 5}; int* p = a; printf(\"%p %p\\n\", p, ++p); // 0x7ffd65cf5b18 0x7ffd65cf5b10 } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"datatype/string.html":{"url":"datatype/string.html","title":"字符串","keywords":"","body":"Golang 字符串 Go 语言中的字符串是一个字节切片，而不是一个字符数组。 特性 字符串是不可变的 定义 s := \"Hello\" // 使用字节切片构造字符串 byteSlice := []byte{0x43, 0x61, 0x66, 0xC3, 0xA9} str := string(byteSlice) for range for index, rune := range s 格式限定符（Format Specifier） %x - 16 进制编码 %c - 字符 示例 func printChars(s string) { for i := 0; i Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"datatype/struct.html":{"url":"datatype/struct.html","title":"结构体","keywords":"","body":"Golang 结构体（Struct） 结构体是字段（field）的集合。定义好的结构体将作为新的类型来处理。 结构体类型 定义 // Named Structure （结构体名首字母大写 => 可导出的类型 Exported Type） type STRUCT_TYPE_NAME struct { field1 T1 // 字段名首字母大小 => Exported Type ...... fieldn Tn } // 匿名结构体（名称首字母小写） var struct_name struct { field1 T1 ...... fieldn Tn } 声明 + 初始化 结构体使用 . 来访问结构体字段。 var struct_name STRUCT_TYPE_NAME // 声明命名结构体变量 struct_name.field1 = ... // 初始化 struct_name.field2 = ... // 声明 + 初始化 var struct_name STRUCT_TYPE_NAME{field1: ..., fieldn: ...} 示例 // 定义 var Person struct { age int name string } // 声明 + 初始化 var person Person person.age = 10 person.name = \"jins\" // 声明时初始化（带有字段名） var person Person{age: 20, name: \"jins\"} var person Person{ age: 20, name: \"jins\", // 如果 } 要换行则需要这个 , } // 声明时初始化（没有字段名） var person Person(20, \"jins\") 结构体指针 结构体字段可以通过结构体指针来访问。对于结构体指针 pointer，我们可以通过 (*pointer).filed 来访问结构体字段 filed，同时 Go 允许使用 pointer.filed 来代替显示的解引用 (*pointer).field。 func main() { var person Person{age: 20, name: \"jins\"} var p *Persion // 返回一个指向结构体值的指针 p = &person // 访问字段 fmt.Println(person.name) // jins fmt.Println((*p).name) // jins fmt.Println(p.name) // jins } 结构体数组/切片 结构体数组 // 声明 var sa [3]Person sa = { {20, \"a\"}, {21, \"b\"}, {22, \"c\"} } func main() {} 结构体零值 基础类型的零值的组合，限忽略的字段。 ``` ## 匿名字段 ```go type Person struct { string // 字段名称与其类型同名 int } 相等性 结构体是值类型，如果两个结构体变量的对应字段均相等（前提是结构体字段是可比较的，比如 map 类型无法比较），则这两个结构体变量相等。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"method.html":{"url":"method.html","title":"方法（method）","keywords":"","body":"方法（Method） 方法本质是一个函数，在 func 关键字与方法名直接加入了特殊的接收器类型。接收器类型可以是结构体类型或者非结构体类型，接收器可以在方法内部访问。 // 接收器类型为 Type 的方法 func (t Type) methodName(parameter list) {} 函数与方法 package main import \"fmt\" type Person struct { name string age int } // 基于类型的方法（Person 是接收器类型，e 是接收器） func (e Person) emthod() { fmt.Printf(\"%s %d\\n\", e.name, e.age) } // 函数 func function(e Person) { fmt.Printf(\"%s %d\\n\", e.name, e.age) } int main() { e := Person { name: \"JinsYin\", age: 26, } e.emthod() // 调用 Person 类型的 f1() function(e) } 有了函数，为什么还需要类： Go 不是纯粹的面向对象编程语言，也不支持 “类”；基于类型的方法可以近似实现 “类” 的功能。 可以在不同类型上定义同名的方法，但不同定义同名的函数 值接收器与指针接收器 值接收器 => 值传递 引用接收器 => 引用传递 package main import ( \"fmt\" ) type Person struct { name string age int } func (e Person) changeName(name string) { e.name = name } func (e *Person) changeAge(age int) { e.age = age // (*e).age == e.age } func main() { e := Person{ name: \"jinsyin\", age: 26, } e.changeName(\"Jins\") fmt.Println(e.name) // jinsyin (&e).changeAge(18) fmt.Println(e.age) // 18 } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"function.html":{"url":"function.html","title":"函数（function）","keywords":"","body":"Golang 函数 内置函数 len：计算（字符串，数组或者切片，map）长度 cap：计算（数组或者切片，map）容量 close：关闭通道 append：追加内容到切片 copy：拷贝数组/切片内容到另一个数组/切片 delete：用于删除map的元素 递归函数 语法格式 func recursion() { recursion() // 调用函数自身 } 递归函数必须设置退出条件，否则递归将陷入无限循环。 范例 // 阶乘 func factorial(n uint64) uint64 { if n > 0 { return n * factorial(n-1) } return 1 } // 斐波那契数列 func fibonacci(n int) int { if n >= 2 { return fibonacci(n-1) + fibonacci(n-2) } return n } func main() { for i := 0; i 参数列表/可变参数 func f(a ...interface{}) { } 原理是将可变参数转换为一个新的切片 只有函数的最后一个参数才允许是可变的 如果要将切片传入可变参数函数，可以在在切片后加上 ... 后缀 // elems 相对于一个 Type 类型的切片 func append(slice []Type, elems ...Type) []Type 命名返回值 下面两种方式是完全等价的。 func f() (x int) { // 函数体中不能再声明变量 x return // 返回值为 x } func f() int { var x int return x } 多返回值 func cal(x, y int) (int, int) { var sum = x + y var diff = x - y return sum, diff } 空白符 _ 被用作空白符，可以表示任何类型的任何值。 sum, _ := cal(3, 4) 命名法 驼峰命名法。 访问权限 常量、变量、函数、结构体名称的首字母大写，表示可以被导出，即允许被其他包访问 常量、变量、函数、结构体名称的首字母小写，表示不能被导出，即只能被本包访问 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"goroutine.html":{"url":"goroutine.html","title":"协程（goroutine）","keywords":"","body":"Golang 协程（goroutine） Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"interface.html":{"url":"interface.html","title":"接口（interface）","keywords":"","body":"Golang 接口（interface） interface 是一种类型，它包含一组方法。如果一个类型实现了一个 interface 中所有方法，我们说类型实现了该 interface。Go 没有显式的关键字用来实现 interface，只需要实现 interface 包含的方法即可。 empty interface 空接口，即不带任何方法的 interface。 定义 type INTERFACE_NAME interface { METHOD_NAME1 [return_type] ...... METHOD_NAMEX [return_type] } 声明与实现 type Person interface { } package main import ( \"fmt\" ) //interface definition type VowelsFinder interface { FindVowels() []rune } type MyString string// MyString implements VowelsFinder func (ms MyString) FindVowels() []rune { var vowels []rune for _, rune := range ms { if rune == 'a' || rune == 'e' || rune == 'i' || rune == 'o' || rune == 'u' { vowels = append(vowels, rune) } } return vowels } func main() { name := MyString(\"Sam Anderson\") var v VowelsFinder v = name // possible since MyString implements VowelsFinder fmt.Printf(\"Vowels are %c\", v.FindVowels()) } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"channel.html":{"url":"channel.html","title":"信道（channel）","keywords":"","body":"Golang 信道（channel） 定义 信道关联着一个数据类型，每个信道只能传输该类型的数据。 chan T 表示 T 类型的信道。零值是 nil。 // 声明 var cnl chan T // 初始化 cnl = make(chan T) 发送和接收 // 读取信道 cnl data := 发送和接收默认是阻塞的，即数据发送到信道时，程序会在相应语句处发生阻塞，直到其他协程从该信道读取到数据，才会解除阻塞，并且读取过程也会一直阻塞。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"concurrency.html":{"url":"concurrency.html","title":"并发（Concurrency）","keywords":"","body":"Golang 并发（Concurrency） Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"cmd/go/":{"url":"cmd/go/","title":"go","keywords":"","body":"go 命令 子命令 简述 go get go run go build 参考 Command go Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"cmd/go/go-build.html":{"url":"cmd/go/go-build.html","title":"go build","keywords":"","body":"go build 命令 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"cmd/go/go-env.html":{"url":"cmd/go/go-env.html","title":"go env","keywords":"","body":"go env 命令 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"cmd/go/go-help.html":{"url":"cmd/go/go-help.html","title":"go help","keywords":"","body":"go help 命令 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"cmd/go/go-install.html":{"url":"cmd/go/go-install.html","title":"go install","keywords":"","body":"go install go install hello 查找 $GOPATH/src 中的项目 hello 在 hello 下搜索属于 main 包下的 main() 函数 在 $GOPATH/bin 下生成二进制文件 hello Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"cmd/go/go-run.html":{"url":"cmd/go/go-run.html","title":"go run","keywords":"","body":"go run 命令 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"cmd/godoc.html":{"url":"cmd/godoc.html","title":"godoc","keywords":"","body":"godoc 命令 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"cmd/gofmt.html":{"url":"cmd/gofmt.html","title":"gofmt","keywords":"","body":"gofmt 命令 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"cmd/cgo.html":{"url":"cmd/cgo.html","title":"cgo","keywords":"","body":"cgo 命令 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"error-handling.html":{"url":"error-handling.html","title":"错误处理","keywords":"","body":"Golang 错误处理 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"extensions.html":{"url":"extensions.html","title":"插件","keywords":"","body":"Golang 插件 Go go get -u -v github.com/nsf/gocode go get -u -v github.com/rogpeppe/godef go get -u -v github.com/golang/lint/golint go get -u -v github.com/lukehoban/go-find-references go get -u -v github.com/lukehoban/go-outline go get -u -v sourcegraph.com/sqs/goreturns go get -u -v golang.org/x/tools/cmd/gorename go get -u -v github.com/tpng/gopkgs go get -u -v github.com/newhook/go-symbols MarkDown markdownlint Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"flowcontrol.html":{"url":"flowcontrol.html","title":"流程控制","keywords":"","body":"流程控制 for Go 语言只有一个循环结构，即 for 循环。需要注意的是，Go 语言的 for 语句没有小括号 ()，但大括号 {} 是必须的。 for 循环包含三个以 ; 分隔的组件： * 初始化语句：第一次迭代之前执行；通常是一句简短的变量声明，且该变量声明仅在 `for` 语句的作用域中可见。 * 条件表达式：每次迭代之前进行判断；一旦条件表达式的值为 `false`，循环将被终止。 * 后置语句：每次迭代之后执行 其中，初始化语句和后置语句都是可选的，当两者都省略后其实就相当于其他编程语言的 while 循环。如果三者都被省略，将进入无限循环。 范例 package main import \"fmt\" func main() { sum := 1 for sum if 可以在条件表达式之前执行一个初始化语句，声明的变量的作用域仅在 if 和 else 语句范围内 表达式外不需要小括号 ()，但大括号 {} 是必须的。 package main import ( \"fmt\" \"math\" ) func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v = %g\\n\", v, lim) } return lim } func main() { // 27 >= 20 // 9 20 fmt.Println( pow(3, 2, 10), pow(3, 3, 20), ) } Switch switch 是一连串 if - else if - else 语句的简便方法。与其他编程语言不同的是，Go 语言只执行选定的 case，而非之后所有的 case（只有当所有 case 都不满足条件才会执行 default 语句），实际上是 Go 语言在每个 case 后面自动提供了 break 语句。若想要执行之后的 case，可以用 fallthrough 语句结束 case。另一点不同的是，switch 的 case 不必是常量，且取值不必是整数。 语法 swtich 的 case 语句从上到下依次执行，直到匹配成功为止。 // 当 i == 0 时 f() 不会被调用 switch i { case 0: case f(): } ` 没有条件的 switch 没有条件的 switch 同 switch true 一样。 switch { case t.Hour() 范例 package main import ( \"fmt\" \"runtime\" ) func main() { fmt.Print(\"Go run on \") /* 由于我是在 Linux 上执行的，所以输出结果为：Go runs on linux. 注意：这里 default 语句块并没有被执行; */ switch os := runtime.GOOS; os { case \"darwin\": fmt.Println(\"OS X.\") case \"linux\": fmt.Println(\"Linux.\") default: fmt.Printf(\"%s.\", os) } } Defer defer 语句将其后调用的函数推迟到外层函数返回之后再执行。 defer 栈 推迟的函数调用（function call）会依次入栈，当外层函数返回后，被推迟的函数会按 后进先出 的顺序依次被调用。 范例 package main import \"fmt\" func main() { /* XXX BBB AAA */ defer fmt.Println(\"AAA\") defer fmt.Println(\"BBB\") fmt.Println(\"XXX\") } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"package.html":{"url":"package.html","title":"包","keywords":"","body":"包 创建自定义包 项目目录结构： src └── project-a └── pkgx └── mathx.go └── main.go mathx.go: package pkgx // 在第一行声明当前源文件属于哪个包，通常包名与源文件所在的文件夹同名 func Max(x, y int) int { // 函数名首字母大小 return x > y ? x : y } 导入包 语法： import packagepath // 自定义包必须是相对于 $GOPATH/src 的路径 main.go： package main import ( \"fmt\" // 导入内置包 \"project-a/pkgx\" // 导入自定义包 ) func main() { a, b := 3, -3 max := pkgx.Max(a, b) // 可见需要避免下定义同名函数 fmt.Printf(\"%d\\n\", max); } init 函数 每个包都可以包含一个或多个（分布于多个文件）init 函数，用于执行初始化任务，或者在开始执行之前验证程序的正确性。此外，init 函数不能显示地被调用。 // 无参数、无返回值 func init() {} 包的初始化顺序： 如果导入了其他包，则优先初始化被导入的包；导入多次，仅初始化一次 初始化包级别（Package Level）的变量 执行 init 函数；如果有多个，则按编译器解析顺序进行执行 空白标识符（Blank Identifier） Go 不允许导入了包而不使用。如果确实需要先导入，暂不使用，可以使用空白标识符。 package main import ( \"fmt\" // 导入内置包 \"project-a/pkgx\" // 导入自定义包 ) var _ = pkgx.Max // 错误屏蔽器 func main() { } package main import ( _ \"project-a/pkgx\" // 仅进行初始化，但不使用包中的函数和变量 ) func main() { } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"variable.html":{"url":"variable.html","title":"变量","keywords":"","body":"变量 定义 声明 默认使用相应类型的 Zero Value 自动初始化变量。 // 语法 var name type // 示例 var age int 声明并初始化 // 语法 var name type = initialvalue // 示例 var age int 25 类型推断（Type Inference） 根据初始值自动推断变量的类型。 // 语法 var name = initialvalue // 示例 var age = 25 声明多个变量 // 语法 var name1, name2 type = initialvalue1, initialvalue2 声明多个不同类型的变量 var { name = \"jinsyin\" age = 26 height int } 简短声明（Short Hand Declaration） 限函数内部。 name := initialvalue 常量 常量使用 const 关键字来声明，但不能使用 := 语法来声明初始化。常量的值在程序编译时确定，而函数调用发生在运行时，所以不能将函数的返回值赋值给常量。 const Pi = 3.14 const name = \"jins\" // 所有双引号括起来的值都是字符串常量，且没有类型！ const str1 string = \"jinsyin\" // 带有类型的常量 var str2 = \"jinsyin\" // 有类型（当代码需要时提供一个相关联的默认类型） Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"keyword/":{"url":"keyword/","title":"关键字","keywords":"","body":"Go 语言关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"keyword/break.html":{"url":"keyword/break.html","title":"break","keywords":"","body":"Golang break 关键字 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"keyword/func.html":{"url":"keyword/func.html","title":"func","keywords":"","body":"Golang func 关键字 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"keyword/package.html":{"url":"keyword/package.html","title":"package","keywords":"","body":"Golang package 关键字 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"keyword/type.html":{"url":"keyword/type.html","title":"type","keywords":"","body":"Golang type 关键字 定义类型别名。 type NEW_TYPE_NAME TYPE_NAME Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"keyword/range.html":{"url":"keyword/range.html","title":"range","keywords":"","body":"range range 关键字用于 for 循环中迭代数组（array）、切片（slice）、通道（channel）、或集合（map）的元素。在数组和切片中返回元素的索引值，在集合中返回 key/value 对中的 key。 范例 package main import \"fmt\" func main() { slice := []int{1, 4, 9} amap := map[string]string{\"name\": \"jim\", \"age\": \"20\"} fmt.Println(sliceSum(slice)) // 14 printMap(amap) // name -> jim // age -> 20 } func sliceSum(slice []int) int { sum := 0 // _ 作为抛弃值，是一个只写变量，其实际值是切片索引；使用抛弃值的原因是 Go 语言中声明的变量必须被使用 for _, elem := range slice { sum += elem } return sum } func printMap(amap map[string]string) { // 还可以省略第二个值 for key := range amap { fmt.Printf(\"%s -> %s\\n\", key, amap[key]) } } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"misc/":{"url":"misc/","title":"misc","keywords":"","body":"Go 杂项 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"misc/grpc/":{"url":"misc/grpc/","title":"grpc","keywords":"","body":"GRPC 什么是 API 在其核心，应用程序编程接口（API）是作为两个单独的软件之间的保证合同的正式规范。 API提供程序定义了它期望的一组操作，数据格式和协议。API的消费者（称为客户端）将使用那些规则，客户端将永远不必担心API本身的内部，只要它遵循规则。 API 技术 TCP / IP 套接字 远程过程调用（RPC） 公共对象请求代理体系结构（CORBA） Java 远程方法调用（RMI）和企业Java Bean（EJB） Microsoft 分布式组件对象模型（DCOM） - 也称为ActiveX Web 服务（SOAP 然后 REST） 参考 Golang 中的微服务 - 第一部分 什么是接口测试 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"misc/ide/":{"url":"misc/ide/","title":"ide","keywords":"","body":"IDE 与编辑器插件 编辑器 插件 Vim & Neovim vim-go Syntastic Visual Studio Code * vscode-go Atom * Go-Plus IDE 描述 GoLand 既可以作为独立 IDE，又可以作为 IntelliJ IDEA Ultimate 的插件 参考 Editor plugins and IDEs IDEs and Plugins for Go Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"misc/ide/atom/":{"url":"misc/ide/atom/","title":"atom","keywords":"","body":"Atom & GoLang Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"misc/ide/vscode/":{"url":"misc/ide/vscode/","title":"vscode","keywords":"","body":"VSCode & GoLang 安装插件 Extensions -> 搜索 “go” -> 选择第一个并安装 配置 // settings.json { ... \"go.buildOnSave\": \"workspace\", \"go.lintOnSave\": \"package\", \"go.vetOnSave\": \"package\", \"go.buildTags\": \"\", \"go.buildFlags\": [], \"go.lintFlags\": [], \"go.vetFlags\": [], \"go.coverOnSave\": false, \"go.useCodeSnippetsOnFunctionSuggest\": false, \"go.formatOnSave\": true, \"go.formatTool\": \"goreturns\", // 打开任意一个 *.go 文件，VS Code 会提示安装相应的包，选择 “Install All” \"go.goroot\": \"/usr/local/go\", \"go.gopath\": \"~/go\", \"go.gocodeAutoBuild\": false ... } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"misc/style/":{"url":"misc/style/","title":"style","keywords":"","body":"GoLang 代码风格 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"pkg/":{"url":"pkg/","title":"pkg","keywords":"","body":"Go Packages 参考 Go Packages Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"pkg/stdlib/":{"url":"pkg/stdlib/","title":"标准库","keywords":"","body":"Go 标准库 参考 Packages Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"pkg/stdlib/io/":{"url":"pkg/stdlib/io/","title":"io","keywords":"","body":"Go 标准库 · io Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"pkg/stdlib/os/":{"url":"pkg/stdlib/os/","title":"os","keywords":"","body":"Go 标准库 · os Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"pkg/3rdparty/":{"url":"pkg/3rdparty/","title":"第三方库","keywords":"","body":"Go 第三方库 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"spec/":{"url":"spec/","title":"spec","keywords":"","body":"Go 语言规范 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"suger/":{"url":"suger/","title":"suger","keywords":"","body":"Go 语法糖 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "},"suger/assignment.html":{"url":"suger/assignment.html","title":":= 语法糖","keywords":"","body":":= 语法糖 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-02-27 "}}